// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leads.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createLead = `-- name: CreateLead :one
INSERT INTO leads (
    tenant_id,
    campaign_id,
    lead_batch_id,
    full_name,
    email_cipher,
    phone_cipher,
    dek_wrapped,
    dek_kms_key_id,
    email_hash,
    phone_hash,
    ip_address,
    company_name,
    address,
    country_code,
    linkedin_contact,
    linkedin_company,
    downloaded_asset_name,
    publisher_name,
    industry,
    revenue_size,
    employee_size,
    region,
    state
)
VALUES (
    $1,  -- tenant_id
    $2,  -- campaign_id
    $3,  -- lead_batch_id
    $4,  -- full_name
    $5,  -- email_cipher
    $6,  -- phone_cipher
    $7,  -- dek_wrapped
    $8,  -- dek_kms_key_id
    $9,  -- email_hash
    $10, -- phone_hash
    NULLIF($11, '')::inet,    -- <-- accept text and cast to inet (empty string -> NULL)
    $12, -- company_name
    $13, -- address
    $14, -- country_code
    $15, -- linkedin_contact
    $16, -- linkedin_company
    $17, -- downloaded_asset_name
    $18, -- publisher_name
    $19, -- industry
    $20, -- revenue_size
    $21,  -- employee_size
    $22,
    $23
)
RETURNING id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
`

type CreateLeadParams struct {
	TenantID            uuid.UUID
	CampaignID          uuid.UUID
	LeadBatchID         uuid.NullUUID
	FullName            sql.NullString
	EmailCipher         []byte
	PhoneCipher         []byte
	DekWrapped          []byte
	DekKmsKeyID         sql.NullString
	EmailHash           sql.NullString
	PhoneHash           sql.NullString
	Column11            interface{}
	CompanyName         sql.NullString
	Address             sql.NullString
	CountryCode         sql.NullString
	LinkedinContact     sql.NullString
	LinkedinCompany     sql.NullString
	DownloadedAssetName sql.NullString
	PublisherName       sql.NullString
	Industry            sql.NullString
	RevenueSize         sql.NullString
	EmployeeSize        sql.NullString
	Region              sql.NullString
	State               sql.NullString
}

func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (Lead, error) {
	row := q.db.QueryRowContext(ctx, createLead,
		arg.TenantID,
		arg.CampaignID,
		arg.LeadBatchID,
		arg.FullName,
		arg.EmailCipher,
		arg.PhoneCipher,
		arg.DekWrapped,
		arg.DekKmsKeyID,
		arg.EmailHash,
		arg.PhoneHash,
		arg.Column11,
		arg.CompanyName,
		arg.Address,
		arg.CountryCode,
		arg.LinkedinContact,
		arg.LinkedinCompany,
		arg.DownloadedAssetName,
		arg.PublisherName,
		arg.Industry,
		arg.RevenueSize,
		arg.EmployeeSize,
		arg.Region,
		arg.State,
	)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.LeadBatchID,
		&i.FullName,
		&i.EmailCipher,
		&i.PhoneCipher,
		&i.DekWrapped,
		&i.DekKmsKeyID,
		&i.EmailHash,
		&i.PhoneHash,
		&i.IpAddress,
		&i.CompanyName,
		&i.Address,
		&i.CountryCode,
		&i.LinkedinContact,
		&i.LinkedinCompany,
		&i.DownloadedAssetName,
		&i.PublisherName,
		&i.Industry,
		&i.RevenueSize,
		&i.EmployeeSize,
		&i.Region,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLead = `-- name: DeleteLead :exec
DELETE FROM leads
WHERE id = $1 AND tenant_id = $2
`

type DeleteLeadParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) DeleteLead(ctx context.Context, arg DeleteLeadParams) error {
	_, err := q.db.ExecContext(ctx, deleteLead, arg.ID, arg.TenantID)
	return err
}

const getLeadByEmailHash = `-- name: GetLeadByEmailHash :one
SELECT id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
FROM leads
WHERE tenant_id = $1 AND email_hash = $2
LIMIT 1
`

type GetLeadByEmailHashParams struct {
	TenantID  uuid.UUID
	EmailHash sql.NullString
}

func (q *Queries) GetLeadByEmailHash(ctx context.Context, arg GetLeadByEmailHashParams) (Lead, error) {
	row := q.db.QueryRowContext(ctx, getLeadByEmailHash, arg.TenantID, arg.EmailHash)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.LeadBatchID,
		&i.FullName,
		&i.EmailCipher,
		&i.PhoneCipher,
		&i.DekWrapped,
		&i.DekKmsKeyID,
		&i.EmailHash,
		&i.PhoneHash,
		&i.IpAddress,
		&i.CompanyName,
		&i.Address,
		&i.CountryCode,
		&i.LinkedinContact,
		&i.LinkedinCompany,
		&i.DownloadedAssetName,
		&i.PublisherName,
		&i.Industry,
		&i.RevenueSize,
		&i.EmployeeSize,
		&i.Region,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
FROM leads
WHERE id = $1 AND tenant_id = $2
`

type GetLeadByIDParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) GetLeadByID(ctx context.Context, arg GetLeadByIDParams) (Lead, error) {
	row := q.db.QueryRowContext(ctx, getLeadByID, arg.ID, arg.TenantID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.LeadBatchID,
		&i.FullName,
		&i.EmailCipher,
		&i.PhoneCipher,
		&i.DekWrapped,
		&i.DekKmsKeyID,
		&i.EmailHash,
		&i.PhoneHash,
		&i.IpAddress,
		&i.CompanyName,
		&i.Address,
		&i.CountryCode,
		&i.LinkedinContact,
		&i.LinkedinCompany,
		&i.DownloadedAssetName,
		&i.PublisherName,
		&i.Industry,
		&i.RevenueSize,
		&i.EmployeeSize,
		&i.Region,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeadsByCampaign = `-- name: ListLeadsByCampaign :many
SELECT id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
FROM leads
WHERE tenant_id = $1 AND campaign_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListLeadsByCampaignParams struct {
	TenantID   uuid.UUID
	CampaignID uuid.UUID
	Limit      int32
	Offset     int32
}

func (q *Queries) ListLeadsByCampaign(ctx context.Context, arg ListLeadsByCampaignParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsByCampaign,
		arg.TenantID,
		arg.CampaignID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lead
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CampaignID,
			&i.LeadBatchID,
			&i.FullName,
			&i.EmailCipher,
			&i.PhoneCipher,
			&i.DekWrapped,
			&i.DekKmsKeyID,
			&i.EmailHash,
			&i.PhoneHash,
			&i.IpAddress,
			&i.CompanyName,
			&i.Address,
			&i.CountryCode,
			&i.LinkedinContact,
			&i.LinkedinCompany,
			&i.DownloadedAssetName,
			&i.PublisherName,
			&i.Industry,
			&i.RevenueSize,
			&i.EmployeeSize,
			&i.Region,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadsForBatch = `-- name: ListLeadsForBatch :many
SELECT id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
FROM leads
WHERE tenant_id = $1 AND lead_batch_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListLeadsForBatchParams struct {
	TenantID    uuid.UUID
	LeadBatchID uuid.NullUUID
	Limit       int32
	Offset      int32
}

func (q *Queries) ListLeadsForBatch(ctx context.Context, arg ListLeadsForBatchParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsForBatch,
		arg.TenantID,
		arg.LeadBatchID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lead
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CampaignID,
			&i.LeadBatchID,
			&i.FullName,
			&i.EmailCipher,
			&i.PhoneCipher,
			&i.DekWrapped,
			&i.DekKmsKeyID,
			&i.EmailHash,
			&i.PhoneHash,
			&i.IpAddress,
			&i.CompanyName,
			&i.Address,
			&i.CountryCode,
			&i.LinkedinContact,
			&i.LinkedinCompany,
			&i.DownloadedAssetName,
			&i.PublisherName,
			&i.Industry,
			&i.RevenueSize,
			&i.EmployeeSize,
			&i.Region,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadsWithFilters = `-- name: ListLeadsWithFilters :many
SELECT id, tenant_id, campaign_id, lead_batch_id, full_name, email_cipher, phone_cipher, dek_wrapped, dek_kms_key_id, email_hash, phone_hash, ip_address, company_name, address, country_code, linkedin_contact, linkedin_company, downloaded_asset_name, publisher_name, industry, revenue_size, employee_size, region, state, created_at, updated_at
FROM leads
WHERE leads.tenant_id = $1
  AND ($2::uuid IS NULL OR campaign_id = $2)
  AND (
        $3::uuid IS NULL
        OR lead_batch_id IN (
            SELECT id FROM lead_batches WHERE supplier_id = $3
        )
      )
ORDER BY created_at DESC
LIMIT $4
`

type ListLeadsWithFiltersParams struct {
	TenantID uuid.UUID
	Column2  uuid.UUID
	Column3  uuid.UUID
	Limit    int32
}

func (q *Queries) ListLeadsWithFilters(ctx context.Context, arg ListLeadsWithFiltersParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsWithFilters,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lead
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CampaignID,
			&i.LeadBatchID,
			&i.FullName,
			&i.EmailCipher,
			&i.PhoneCipher,
			&i.DekWrapped,
			&i.DekKmsKeyID,
			&i.EmailHash,
			&i.PhoneHash,
			&i.IpAddress,
			&i.CompanyName,
			&i.Address,
			&i.CountryCode,
			&i.LinkedinContact,
			&i.LinkedinCompany,
			&i.DownloadedAssetName,
			&i.PublisherName,
			&i.Industry,
			&i.RevenueSize,
			&i.EmployeeSize,
			&i.Region,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
