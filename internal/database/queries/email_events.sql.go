// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email_events.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createEmailEvent = `-- name: CreateEmailEvent :one
INSERT INTO email_events (
    email,
    event_type,
    event_subtype,
    reason,
    diagnostic_code,
    feedback_id,
    message_id,
    raw_data
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data
`

type CreateEmailEventParams struct {
	Email          string
	EventType      string
	EventSubtype   sql.NullString
	Reason         sql.NullString
	DiagnosticCode sql.NullString
	FeedbackID     sql.NullString
	MessageID      sql.NullString
	RawData        pqtype.NullRawMessage
}

func (q *Queries) CreateEmailEvent(ctx context.Context, arg CreateEmailEventParams) (EmailEvent, error) {
	row := q.db.QueryRowContext(ctx, createEmailEvent,
		arg.Email,
		arg.EventType,
		arg.EventSubtype,
		arg.Reason,
		arg.DiagnosticCode,
		arg.FeedbackID,
		arg.MessageID,
		arg.RawData,
	)
	var i EmailEvent
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EventType,
		&i.EventSubtype,
		&i.Reason,
		&i.DiagnosticCode,
		&i.FeedbackID,
		&i.MessageID,
		&i.CreatedAt,
		&i.RawData,
	)
	return i, err
}

const deleteOldEmailEvents = `-- name: DeleteOldEmailEvents :exec
DELETE FROM email_events
WHERE created_at < $1
`

func (q *Queries) DeleteOldEmailEvents(ctx context.Context, createdAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteOldEmailEvents, createdAt)
	return err
}

const getBounceCountByEmail = `-- name: GetBounceCountByEmail :one
SELECT COUNT(*) FROM email_events
WHERE email = $1 AND event_type = 'bounce'
`

func (q *Queries) GetBounceCountByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBounceCountByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBouncesByType = `-- name: GetBouncesByType :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE event_type = 'bounce' AND event_subtype = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetBouncesByTypeParams struct {
	EventSubtype sql.NullString
	Limit        int32
	Offset       int32
}

func (q *Queries) GetBouncesByType(ctx context.Context, arg GetBouncesByTypeParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getBouncesByType, arg.EventSubtype, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComplaintCountByEmail = `-- name: GetComplaintCountByEmail :one
SELECT COUNT(*) FROM email_events
WHERE email = $1 AND event_type = 'complaint'
`

func (q *Queries) GetComplaintCountByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getComplaintCountByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDailyEventStats = `-- name: GetDailyEventStats :many
SELECT
    DATE(created_at) as date,
    event_type,
    COUNT(*) as count
FROM email_events
WHERE created_at >= $1
GROUP BY DATE(created_at), event_type
ORDER BY date DESC, event_type
LIMIT $2 OFFSET $3
`

type GetDailyEventStatsParams struct {
	CreatedAt sql.NullTime
	Limit     int32
	Offset    int32
}

type GetDailyEventStatsRow struct {
	Date      time.Time
	EventType string
	Count     int64
}

func (q *Queries) GetDailyEventStats(ctx context.Context, arg GetDailyEventStatsParams) ([]GetDailyEventStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyEventStats, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyEventStatsRow
	for rows.Next() {
		var i GetDailyEventStatsRow
		if err := rows.Scan(&i.Date, &i.EventType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailEventByID = `-- name: GetEmailEventByID :one
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE id = $1
`

func (q *Queries) GetEmailEventByID(ctx context.Context, id uuid.UUID) (EmailEvent, error) {
	row := q.db.QueryRowContext(ctx, getEmailEventByID, id)
	var i EmailEvent
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EventType,
		&i.EventSubtype,
		&i.Reason,
		&i.DiagnosticCode,
		&i.FeedbackID,
		&i.MessageID,
		&i.CreatedAt,
		&i.RawData,
	)
	return i, err
}

const getEmailEventsByEmail = `-- name: GetEmailEventsByEmail :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE email = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailEventsByEmailParams struct {
	Email  string
	Limit  int32
	Offset int32
}

func (q *Queries) GetEmailEventsByEmail(ctx context.Context, arg GetEmailEventsByEmailParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEmailEventsByEmail, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailEventsByEmailAndType = `-- name: GetEmailEventsByEmailAndType :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE email = $1 AND event_type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetEmailEventsByEmailAndTypeParams struct {
	Email     string
	EventType string
	Limit     int32
	Offset    int32
}

func (q *Queries) GetEmailEventsByEmailAndType(ctx context.Context, arg GetEmailEventsByEmailAndTypeParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEmailEventsByEmailAndType,
		arg.Email,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailEventsByEmailPaginated = `-- name: GetEmailEventsByEmailPaginated :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE email = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailEventsByEmailPaginatedParams struct {
	Email  string
	Limit  int32
	Offset int32
}

func (q *Queries) GetEmailEventsByEmailPaginated(ctx context.Context, arg GetEmailEventsByEmailPaginatedParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEmailEventsByEmailPaginated, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailEventsByType = `-- name: GetEmailEventsByType :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE event_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailEventsByTypeParams struct {
	EventType string
	Limit     int32
	Offset    int32
}

func (q *Queries) GetEmailEventsByType(ctx context.Context, arg GetEmailEventsByTypeParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEmailEventsByType, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailEventsInDateRange = `-- name: GetEmailEventsInDateRange :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetEmailEventsInDateRangeParams struct {
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
	Limit       int32
	Offset      int32
}

func (q *Queries) GetEmailEventsInDateRange(ctx context.Context, arg GetEmailEventsInDateRangeParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEmailEventsInDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsSummaryByEmail = `-- name: GetEventsSummaryByEmail :one
SELECT 
    email,
    COUNT(*) FILTER (WHERE event_type = 'bounce') as bounce_count,
    COUNT(*) FILTER (WHERE event_type = 'complaint') as complaint_count,
    COUNT(*) FILTER (WHERE event_type = 'delivery') as delivery_count,
    MAX(created_at) FILTER (WHERE event_type = 'bounce') as last_bounce_at,
    MAX(created_at) FILTER (WHERE event_type = 'complaint') as last_complaint_at,
    MAX(created_at) FILTER (WHERE event_type = 'delivery') as last_delivery_at
FROM email_events
WHERE email = $1
GROUP BY email
`

type GetEventsSummaryByEmailRow struct {
	Email           string
	BounceCount     int64
	ComplaintCount  int64
	DeliveryCount   int64
	LastBounceAt    interface{}
	LastComplaintAt interface{}
	LastDeliveryAt  interface{}
}

func (q *Queries) GetEventsSummaryByEmail(ctx context.Context, email string) (GetEventsSummaryByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getEventsSummaryByEmail, email)
	var i GetEventsSummaryByEmailRow
	err := row.Scan(
		&i.Email,
		&i.BounceCount,
		&i.ComplaintCount,
		&i.DeliveryCount,
		&i.LastBounceAt,
		&i.LastComplaintAt,
		&i.LastDeliveryAt,
	)
	return i, err
}

const getLatestEventByEmail = `-- name: GetLatestEventByEmail :one
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE email = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestEventByEmail(ctx context.Context, email string) (EmailEvent, error) {
	row := q.db.QueryRowContext(ctx, getLatestEventByEmail, email)
	var i EmailEvent
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EventType,
		&i.EventSubtype,
		&i.Reason,
		&i.DiagnosticCode,
		&i.FeedbackID,
		&i.MessageID,
		&i.CreatedAt,
		&i.RawData,
	)
	return i, err
}

const getRecentEmailEvents = `-- name: GetRecentEmailEvents :many
SELECT id, email, event_type, event_subtype, reason, diagnostic_code, feedback_id, message_id, created_at, raw_data FROM email_events
WHERE created_at > $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetRecentEmailEventsParams struct {
	CreatedAt sql.NullTime
	Limit     int32
	Offset    int32
}

func (q *Queries) GetRecentEmailEvents(ctx context.Context, arg GetRecentEmailEventsParams) ([]EmailEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecentEmailEvents, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailEvent
	for rows.Next() {
		var i EmailEvent
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EventType,
			&i.EventSubtype,
			&i.Reason,
			&i.DiagnosticCode,
			&i.FeedbackID,
			&i.MessageID,
			&i.CreatedAt,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
