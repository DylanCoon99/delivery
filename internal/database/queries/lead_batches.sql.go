// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lead_batches.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createLeadBatch = `-- name: CreateLeadBatch :one
INSERT INTO lead_batches (
    tenant_id,
    campaign_id,
    supplier_id,
    batch_name,
    total_leads,
    status,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
RETURNING id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
`

type CreateLeadBatchParams struct {
	TenantID   uuid.UUID
	CampaignID uuid.UUID
	SupplierID uuid.NullUUID
	BatchName  string
	TotalLeads sql.NullInt32
	Status     sql.NullString
}

func (q *Queries) CreateLeadBatch(ctx context.Context, arg CreateLeadBatchParams) (LeadBatch, error) {
	row := q.db.QueryRowContext(ctx, createLeadBatch,
		arg.TenantID,
		arg.CampaignID,
		arg.SupplierID,
		arg.BatchName,
		arg.TotalLeads,
		arg.Status,
	)
	var i LeadBatch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.SupplierID,
		&i.BatchName,
		&i.TotalLeads,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeadBatch = `-- name: DeleteLeadBatch :exec
DELETE FROM lead_batches
WHERE id = $1
  AND tenant_id = $2
`

type DeleteLeadBatchParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) DeleteLeadBatch(ctx context.Context, arg DeleteLeadBatchParams) error {
	_, err := q.db.ExecContext(ctx, deleteLeadBatch, arg.ID, arg.TenantID)
	return err
}

const getLeadBatchByID = `-- name: GetLeadBatchByID :one
SELECT id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
FROM lead_batches
WHERE id = $1
  AND tenant_id = $2
LIMIT 1
`

type GetLeadBatchByIDParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) GetLeadBatchByID(ctx context.Context, arg GetLeadBatchByIDParams) (LeadBatch, error) {
	row := q.db.QueryRowContext(ctx, getLeadBatchByID, arg.ID, arg.TenantID)
	var i LeadBatch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.SupplierID,
		&i.BatchName,
		&i.TotalLeads,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementLeadCount = `-- name: IncrementLeadCount :one
UPDATE lead_batches
SET total_leads = total_leads + $3,
    updated_at = NOW()
WHERE id = $1
  AND tenant_id = $2
RETURNING id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
`

type IncrementLeadCountParams struct {
	ID         uuid.UUID
	TenantID   uuid.UUID
	TotalLeads sql.NullInt32
}

func (q *Queries) IncrementLeadCount(ctx context.Context, arg IncrementLeadCountParams) (LeadBatch, error) {
	row := q.db.QueryRowContext(ctx, incrementLeadCount, arg.ID, arg.TenantID, arg.TotalLeads)
	var i LeadBatch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.SupplierID,
		&i.BatchName,
		&i.TotalLeads,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeadBatchesByCampaign = `-- name: ListLeadBatchesByCampaign :many
SELECT id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
FROM lead_batches
WHERE campaign_id = $1
  AND tenant_id = $2
ORDER BY created_at DESC
`

type ListLeadBatchesByCampaignParams struct {
	CampaignID uuid.UUID
	TenantID   uuid.UUID
}

func (q *Queries) ListLeadBatchesByCampaign(ctx context.Context, arg ListLeadBatchesByCampaignParams) ([]LeadBatch, error) {
	rows, err := q.db.QueryContext(ctx, listLeadBatchesByCampaign, arg.CampaignID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadBatch
	for rows.Next() {
		var i LeadBatch
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CampaignID,
			&i.SupplierID,
			&i.BatchName,
			&i.TotalLeads,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadBatchesBySupplier = `-- name: ListLeadBatchesBySupplier :many
SELECT id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
FROM lead_batches
WHERE supplier_id = $1
  AND tenant_id = $2
  AND campaign_id = $3
ORDER BY created_at DESC
`

type ListLeadBatchesBySupplierParams struct {
	SupplierID uuid.NullUUID
	TenantID   uuid.UUID
	CampaignID uuid.UUID
}

func (q *Queries) ListLeadBatchesBySupplier(ctx context.Context, arg ListLeadBatchesBySupplierParams) ([]LeadBatch, error) {
	rows, err := q.db.QueryContext(ctx, listLeadBatchesBySupplier, arg.SupplierID, arg.TenantID, arg.CampaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeadBatch
	for rows.Next() {
		var i LeadBatch
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CampaignID,
			&i.SupplierID,
			&i.BatchName,
			&i.TotalLeads,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeadBatchStatus = `-- name: UpdateLeadBatchStatus :one
UPDATE lead_batches
SET status = $3,
    updated_at = NOW()
WHERE id = $1
  AND tenant_id = $2
RETURNING id, tenant_id, campaign_id, supplier_id, batch_name, total_leads, status, created_at, updated_at
`

type UpdateLeadBatchStatusParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
	Status   sql.NullString
}

func (q *Queries) UpdateLeadBatchStatus(ctx context.Context, arg UpdateLeadBatchStatusParams) (LeadBatch, error) {
	row := q.db.QueryRowContext(ctx, updateLeadBatchStatus, arg.ID, arg.TenantID, arg.Status)
	var i LeadBatch
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CampaignID,
		&i.SupplierID,
		&i.BatchName,
		&i.TotalLeads,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTotalLeadsForBatch = `-- name: UpdateTotalLeadsForBatch :exec
UPDATE lead_batches lb
SET total_leads = (
    SELECT COUNT(*) 
    FROM leads l 
    WHERE l.lead_batch_id = lb.id
)
WHERE lb.id = $1
`

func (q *Queries) UpdateTotalLeadsForBatch(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateTotalLeadsForBatch, id)
	return err
}
