// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: delivery_jobs.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createDeliveryJob = `-- name: CreateDeliveryJob :one

INSERT INTO delivery_jobs (
    tenant_id,
    buyer_id,
    delivery_method_id,
    delivery_id,
    scheduled_at,
    delivered_at,
    last_error,
    payload,
    description
)
VALUES (
    $1,                -- tenant_id
    $2,                -- buyer_id
    $3,                -- delivery_method_id
    $4,                -- delivery_id
    $5,                -- scheduled_at
    $6,                -- delivered_at
    $7,                -- last_error
    $8,                -- payload (jsonb)
    $9                 -- description
)
RETURNING id, tenant_id, buyer_id, delivery_method_id, delivery_id, payload, description, scheduled_at, delivered_at, status, last_error, attempts, created_at, updated_at
`

type CreateDeliveryJobParams struct {
	TenantID         uuid.UUID
	BuyerID          uuid.UUID
	DeliveryMethodID uuid.UUID
	DeliveryID       uuid.NullUUID
	ScheduledAt      time.Time
	DeliveredAt      sql.NullTime
	LastError        sql.NullString
	Payload          json.RawMessage
	Description      sql.NullString
}

// ========================================
// DeliveryJobs SQL Queries (Multi-Tenant)
// Updated to support payload, description, delivered_at
// ========================================
func (q *Queries) CreateDeliveryJob(ctx context.Context, arg CreateDeliveryJobParams) (DeliveryJob, error) {
	row := q.db.QueryRowContext(ctx, createDeliveryJob,
		arg.TenantID,
		arg.BuyerID,
		arg.DeliveryMethodID,
		arg.DeliveryID,
		arg.ScheduledAt,
		arg.DeliveredAt,
		arg.LastError,
		arg.Payload,
		arg.Description,
	)
	var i DeliveryJob
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BuyerID,
		&i.DeliveryMethodID,
		&i.DeliveryID,
		&i.Payload,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveredAt,
		&i.Status,
		&i.LastError,
		&i.Attempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDeliveryJob = `-- name: DeleteDeliveryJob :exec
DELETE FROM delivery_jobs
WHERE id = $1
  AND tenant_id = $2
`

type DeleteDeliveryJobParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) DeleteDeliveryJob(ctx context.Context, arg DeleteDeliveryJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteDeliveryJob, arg.ID, arg.TenantID)
	return err
}

const getDeliveryJob = `-- name: GetDeliveryJob :one
SELECT id, tenant_id, buyer_id, delivery_method_id, delivery_id, payload, description, scheduled_at, delivered_at, status, last_error, attempts, created_at, updated_at
FROM delivery_jobs
WHERE id = $1
  AND tenant_id = $2
LIMIT 1
`

type GetDeliveryJobParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) GetDeliveryJob(ctx context.Context, arg GetDeliveryJobParams) (DeliveryJob, error) {
	row := q.db.QueryRowContext(ctx, getDeliveryJob, arg.ID, arg.TenantID)
	var i DeliveryJob
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BuyerID,
		&i.DeliveryMethodID,
		&i.DeliveryID,
		&i.Payload,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveredAt,
		&i.Status,
		&i.LastError,
		&i.Attempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDueJobs = `-- name: GetDueJobs :many
SELECT id, tenant_id, buyer_id, delivery_method_id, delivery_id, payload, description, scheduled_at, delivered_at, status, last_error, attempts, created_at, updated_at
FROM delivery_jobs
WHERE status = 'pending'
  AND scheduled_at <= NOW()
ORDER BY scheduled_at ASC
LIMIT 100
`

func (q *Queries) GetDueJobs(ctx context.Context) ([]DeliveryJob, error) {
	rows, err := q.db.QueryContext(ctx, getDueJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryJob
	for rows.Next() {
		var i DeliveryJob
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BuyerID,
			&i.DeliveryMethodID,
			&i.DeliveryID,
			&i.Payload,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveredAt,
			&i.Status,
			&i.LastError,
			&i.Attempts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementDeliveryJobAttempts = `-- name: IncrementDeliveryJobAttempts :exec
UPDATE delivery_jobs 
SET attempts = attempts + 1,
    updated_at = now()
WHERE id = $1 AND tenant_id = $2
`

type IncrementDeliveryJobAttemptsParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

func (q *Queries) IncrementDeliveryJobAttempts(ctx context.Context, arg IncrementDeliveryJobAttemptsParams) error {
	_, err := q.db.ExecContext(ctx, incrementDeliveryJobAttempts, arg.ID, arg.TenantID)
	return err
}

const listPendingJobs = `-- name: ListPendingJobs :many
SELECT id, tenant_id, buyer_id, delivery_method_id, delivery_id, payload, description, scheduled_at, delivered_at, status, last_error, attempts, created_at, updated_at
FROM delivery_jobs
WHERE status = 'pending'
  AND tenant_id = $1
ORDER BY scheduled_at ASC, created_at ASC
LIMIT $2 OFFSET $3
`

type ListPendingJobsParams struct {
	TenantID uuid.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) ListPendingJobs(ctx context.Context, arg ListPendingJobsParams) ([]DeliveryJob, error) {
	rows, err := q.db.QueryContext(ctx, listPendingJobs, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryJob
	for rows.Next() {
		var i DeliveryJob
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BuyerID,
			&i.DeliveryMethodID,
			&i.DeliveryID,
			&i.Payload,
			&i.Description,
			&i.ScheduledAt,
			&i.DeliveredAt,
			&i.Status,
			&i.LastError,
			&i.Attempts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryJobStatus = `-- name: UpdateDeliveryJobStatus :one
UPDATE delivery_jobs
SET status = $2,
    last_error = $4,
    delivered_at = CASE WHEN $2 = 'success' THEN now() ELSE delivered_at END,
    updated_at = now()
WHERE id = $1
  AND tenant_id = $3
RETURNING id, tenant_id, buyer_id, delivery_method_id, delivery_id, payload, description, scheduled_at, delivered_at, status, last_error, attempts, created_at, updated_at
`

type UpdateDeliveryJobStatusParams struct {
	ID        uuid.UUID
	Status    string
	TenantID  uuid.UUID
	LastError sql.NullString
}

func (q *Queries) UpdateDeliveryJobStatus(ctx context.Context, arg UpdateDeliveryJobStatusParams) (DeliveryJob, error) {
	row := q.db.QueryRowContext(ctx, updateDeliveryJobStatus,
		arg.ID,
		arg.Status,
		arg.TenantID,
		arg.LastError,
	)
	var i DeliveryJob
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BuyerID,
		&i.DeliveryMethodID,
		&i.DeliveryID,
		&i.Payload,
		&i.Description,
		&i.ScheduledAt,
		&i.DeliveredAt,
		&i.Status,
		&i.LastError,
		&i.Attempts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
